<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Comparison</title>
    <style>
        /* Clean body for iframe usage */
        body {
            font-family: 'Google Sans', 'Noto Sans', sans-serif;
            margin: 0;
            padding: 0;
            background-color: transparent;
            overflow: hidden;
        }

        /* --- Layout Containers --- */
        .model-container {
            display: flex;
            flex-direction: row;
            justify-content: space-between;
            gap: 10px;
            width: 100%;
            height: 400px;
        }

        .model-wrapper-comparison {
            position: relative;
            flex: 1;
            background: #f0f0f0;
            border-radius: 8px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* --- Labels --- */
        .model-label {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: bold;
            z-index: 10;
            pointer-events: none;
        }

        /* --- The Canvas Area --- */
        .three-canvas-container {
            width: 100%;
            height: 100%;
            display: block;
            outline: none;
        }

        /* --- Thumbnail Strip --- */
        .thumbnail-wrapper {
            text-align: center;
            margin-top: 15px;
        }
        
        .thumbnail-container {
            display: inline-flex;
            gap: 10px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 12px;
        }
        
        .thumbnail-container img, 
        .thumbnail-container video {
            width: 80px;
            height: 60px;
            object-fit: cover;
            border-radius: 6px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: transform 0.2s, border-color 0.2s;
            background: #ddd;
        }
        
        .thumbnail-container img:hover, 
        .thumbnail-container video:hover {
            transform: scale(1.05);
            border-color: #3273dc;
        }
        
        .thumbnail-container .selected {
            border-color: #3273dc;
            transform: scale(1.05);
        }

        /* Loading Overlay */
        .loading-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #333;
            background: rgba(255,255,255,0.8);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            display: none; 
            z-index: 5;
            pointer-events: none;
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <!-- MAIN COMPARISON CONTAINER -->
    <div class="model-container">
        
        <!-- Viewer 1: VGGT (Baseline) -->
        <div class="model-wrapper-comparison">
            <div class="model-label">VGGT</div>
            <div class="loading-overlay" id="loading1">Loading...</div>
            <div id="canvas1" class="three-canvas-container"></div>
        </div>

        <!-- Viewer 2: VGGT + Ours -->
        <div class="model-wrapper-comparison">
            <div class="model-label">VGGT + Ours</div>
            <div class="loading-overlay" id="loading2">Loading...</div>
            <div id="canvas2" class="three-canvas-container"></div>
        </div>

    </div>

    <!-- THUMBNAIL STRIP -->
    <div class="thumbnail-wrapper">
        <div class="thumbnail-container">                
            <img src="resources/3d_vis/kitchen.png" name="kitchen" class="selected">
            <img src="resources/3d_vis/chess.png" name="chess">
            <img src="resources/3d_vis/lecture.png" name="lecture">
            <img src="resources/3d_vis/classroom.png" name="classroom">
            <img src="resources/3d_vis/eth3d.png" name="eth3d">
            <img src="resources/3d_vis/hammer.jpg" name="hammer">
            <img src="resources/3d_vis/storageroom.jpg" name="storageroom">
            <img src="resources/3d_vis/tree.png" name="tree">
        </div>  
    </div>

    <!-- JAVASCRIPT LOGIC -->
    <script type="module">
        import * as THREE from 'three';
        import { PLYLoader } from 'three/addons/loaders/PLYLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- CONFIGURATION ---
        const USE_REAL_FILES = true; 
        const POINT_SIZE = 0.003; 

        const basePaths = {
            baseline: 'resources/3d_vis/vggt/', 
            ours: 'resources/3d_vis/vggt+ours/'      
        };

        let currentSceneName = 'kitchen';
        let debounceTimer = null;
        const viewers = [];

        // --- INITIALIZATION ---
        function initViewer(containerId, loadingId) {
            const container = document.getElementById(containerId);
            const loadingElem = document.getElementById(loadingId);

            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);

            const camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 100);
            camera.position.set(0, 0, 2); // Default start

            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(5, 10, 7);
            scene.add(dirLight);

            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.1;

            window.addEventListener('resize', () => {
                if(container.clientWidth === 0) return;
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            });

            return { scene, camera, controls, renderer, loadingElem, pointCloud: null };
        }

        viewers.push(initViewer('canvas1', 'loading1'));
        viewers.push(initViewer('canvas2', 'loading2'));

        // --- SYNCHRONIZE CAMERAS ---
        let isSyncing = false; 
        const syncViewers = (sourceIndex) => {
            if (isSyncing) return; 
            isSyncing = true;
            const source = viewers[sourceIndex];
            viewers.forEach((target, i) => {
                if (i !== sourceIndex) {
                    target.camera.position.copy(source.camera.position);
                    target.camera.rotation.copy(source.camera.rotation);
                    target.camera.zoom = source.camera.zoom;
                    target.controls.target.copy(source.controls.target);
                    target.controls.update();
                }
            });
            isSyncing = false;
        };
        viewers.forEach((v, index) => {
            v.controls.addEventListener('change', () => syncViewers(index));
        });

        // --- HELPER: FIT CAMERA TO OBJECT ---
        // This calculates the bounding sphere of the object and moves the camera
        // back just enough to see the whole thing.
        function fitCameraToSelection(viewer, object) {
            const box = new THREE.Box3().setFromObject(object);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());
            
            // Get the max dimension (width, height, or depth)
            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = viewer.camera.fov * (Math.PI / 180);
            let cameraZ = Math.abs(maxDim / 2 * Math.tan(fov * 2)); // Basic trig to fit height
            
            // Add some padding multiplier so it's not touching the edges
            cameraZ *= 1.5; 

            // Reset camera to look at the center of the object from the calculated distance
            viewer.camera.position.set(center.x, center.y, cameraZ);
            viewer.camera.lookAt(center);
            
            // Update controls to rotate around the new center
            viewer.controls.target.copy(center);
            viewer.controls.update();
        }

        // --- LOADING LOGIC ---
        function loadModel(viewerIndex, type, sceneNameRequest) {
            const viewer = viewers[viewerIndex];
            const { scene, loadingElem } = viewer;

            if (viewer.pointCloud) {
                scene.remove(viewer.pointCloud);
                if(viewer.pointCloud.geometry) viewer.pointCloud.geometry.dispose();
                if(viewer.pointCloud.material) viewer.pointCloud.material.dispose();
                viewer.pointCloud = null;
            }

            loadingElem.style.display = 'block';

            if (USE_REAL_FILES) {
                const loader = new PLYLoader();
                const url = `${basePaths[type]}${sceneNameRequest}.ply`;
                
                loader.load(url, (geometry) => {
                    if (currentSceneName !== sceneNameRequest) return; 

                    const material = new THREE.PointsMaterial({ 
                        size: POINT_SIZE, 
                        vertexColors: true 
                    });

                    const pointCloud = new THREE.Points(geometry, material);
                    
                    // Center geometry
                    geometry.computeBoundingBox();
                    const center = geometry.boundingBox.getCenter(new THREE.Vector3());
                    pointCloud.position.sub(center); 
                    pointCloud.rotation.x = -Math.PI; 

                    scene.add(pointCloud);
                    viewer.pointCloud = pointCloud;
                    loadingElem.style.display = 'none';

                    // --- NEW LOGIC: FORCE CAMERA RESET ON LOAD ---
                    // We only do this for the first viewer (Baseline) to avoid conflict.
                    // Then we sync the second viewer to match it.
                    if (viewerIndex === 0) {
                        fitCameraToSelection(viewer, pointCloud);
                        syncViewers(0); // Force Viewer 2 to snap to this new angle
                    }

                }, undefined, (err) => {
                    if (currentSceneName === sceneNameRequest) {
                        console.error("Failed to load:", url, err);
                        loadingElem.textContent = "File not found";
                    }
                });
            } else {
                // Mock loading
                setTimeout(() => {
                    if (currentSceneName !== sceneNameRequest) return;
                    // ... (mock geometry code same as before) ...
                }, 200); 
            }
        }

        function updateAllViewers() {
            loadModel(0, 'baseline', currentSceneName);
            loadModel(1, 'ours', currentSceneName);
        }

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            viewers.forEach(v => v.renderer.render(v.scene, v.camera));
        }
        animate();

        // --- THUMBNAIL LOGIC ---
        const thumbnails = document.querySelectorAll('.thumbnail-container img, .thumbnail-container video');
        thumbnails.forEach(thumb => {
            thumb.addEventListener('mouseover', () => {
                thumbnails.forEach(t => t.classList.remove('selected'));
                thumb.classList.add('selected');

                clearTimeout(debounceTimer);
                debounceTimer = setTimeout(() => {
                    const newName = thumb.getAttribute('name');
                    if (newName !== currentSceneName) {
                        currentSceneName = newName;
                        updateAllViewers();
                    }
                }, 200);
            });
        });

        updateAllViewers();
    </script>
</body>
</html>